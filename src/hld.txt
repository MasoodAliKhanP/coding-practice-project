Domain Modeling is a method to describe and model entities and the relationships between them, 
 which collectively represent the problem domain space.
 
 
Domain-driven design (DDD) is a major software design approach,focusing on modeling software to match 
 a domain according to input from that domain's experts (Domain Expert).

Under domain-driven design, the structure and language of software code (class names, class methods, 
class variables) should match the business domain. For example: if software processes loan applications, 
it might have classes like loan application, customers, and methods such as accept offer and withdraw.


HLD:
-- Design

1. Requirement clarification
    - Think of all the activities then ask what else to add or consider

2. Estimate the scale / back of envelope calculation
     - number of tweets
     - how much storage if photos and videos
     - network band width - requests per second - to manage traffic - load balancing

3. Expected APIs
     - postTweet(user_id, tweet_data, tweet_location, user_location, timestamp, â€¦)  

4. Data Model
     - Identify entities and its interaction
        User: UserID, Name, Email, DoB, CreationDate, LastLogin, etc.
        Tweet: TweetID, Content, TweetLocation, NumberOfLikes, TimeStamp, etc.
        UserFollow: UserID1, UserID2
        FavoriteTweets: UserID, TweetID, TimeStamp

        Which database NoSql or MySql?


5. Block Diagram
    - incoming client request - api gateway - load balancer - reverse proxy - Multiple data centers - databases - file storage
    - 																					|
    																		multiple instances of servers
																						|
																					cache(redis etc).												
6. Detailed design

7. Failure points - enough replicas?



MYSQL VS NOSQL
Absolutely agree with the two answers. NoSQL has matured and companies are giving up on consistency 
over availability, but again the basic approach of selecting any technology stays the same: "Its all as per 
your requirement and purpose"

A. If your data requirement is to perform in isolation or is transaction based (requires high ACID compliance) - MySQL
	-The property of isolation ensures that when we execute the transactions concurrently, it will result in 
	 such a state that's equivalent to the achieved state that was serially executed in a particular order.
B. Anything that defines the complex relationship (parent child) and needs joins - MySQL

C. Ground up Solution that has potential needs of huge or unorganized data, which would eventually 
scale out instead of scale up - NoSQL (Horizontal scaling)

D. Blazing fast data reads & writes - NoSQL


We are currently building a product in house where we had to go through many such questions. 
The best solution we found was to divide our application as per our needs. 
For example, 
	- event logs or user behavior can be captured in NoSQL, eventually this would be used for further analysis etc.. 
	- Real world relation or accounting can be handled in MySQL.
	
	
Acid properties:
Atomicity - transaction ek saath hota ya toh ni hota
Consistency - transaction se pehle aur uske baad db consistent rehna
Isolation  - Ek saath kai transactions independently chalte, without interference.
Durability - successful transaction ke changes, system failure hone ke bavajud reflect hote.



Microservices design patterns:
Decomposition - to break monolithic service in to small services
Strangular patttern - break monolithic into small services and then slowly move traffic from moonlithic to
new microservices - a new service receives requests and decides where to send traffic

Saga pattern: 
Micro service with common data base:
 - problems
 1. if one service receives way more requests than other then scaling has to be done which applies for all
 service. vertical scaling
 2. deleytion of coloum needed for one service then need to think where it breaks for other service.
 
 easiness:
 1. transactions
 2. join queries
 
 
Microservices with individual databases:
- solved above problems but intoduces challanges of transactions and join queries

transaction probolem - saga pattern
joni queries - CQRS









